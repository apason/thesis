%% History:
%% December 2020 Veli Mäkinen removed obsolete options related to 40 cr theses
%% May 2019 Tomi Männistö, Antti-Pekka Tuovinen proofreading; 30 vs. 40 cr theses, etc.
%% May 2019 Tomi Männistö changed from babelbib to bibtex; Abstract page (and other pages as well) reformatting.
%% January–May 2019 several issues fixed by Niko Mäkitalo; long fields in abstract
%% March 2018 template file extended by Lea Kutvonen to exploit HYthesisML.cls.
%% Feb2018 This template file for the use of HYgraduML.cls was  modified by Veli Mäkinen from HY_fysiikka_LuKtemplate.tex
%% authored by Roope Halonen ja Tomi Vainio in 2017.
%% Some text is also inherited from engl_malli.tex versions by Kutvonen, Erkiö, Mäkelä, Verkamo, Kurhila, and
%% Nykänen, to accompany tktltiki.cls (by Puolakka 2002).


%% Follow comments to support use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 1: Choose options for MSc / BSc / seminar layout and your bibliographic style
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  Language: 
%%      finnish, swedish, or english
%%  Pagination (use twoside by default)  
%%      oneside or twoside,
%%  Study programme / kind of report
%%      csm  = Master's thesis in Computer Science Master's Programme;
%%      tkt = Bachelor's thesis in Computer Science Bachelor's Programme;
%%      seminar = seminar report
%%  For Master's thesis choose your line or track:
%%      (30 cr thesis, 2020 onwards, Master's Programme in Computer Science = csm)
%%      software-track-2020 = Software study track
%%      algorithms-track-2020 = Algorithms study track
%%      networking-track-2020 = Networking study track
%%
%%      (30 cr thesis, Master's Programme in Computer Science = csm)
%%      sw-track-2018 = Software Systems study track
%%      alko-track-2018 = Algorithms study track
%%      nodes-track-2018 = Networking and Services study track
%%
%%      (30 cr thesis, Master's Programme in Computer Science = csm)
%%      sw-line-2017 =  Software systems subprogramme
%%      alko-line-2017 = Algorithms, Data Analytics and Machine Learning subprogramme
%%      bio-line-2017 = Algorithmic Bioinformatics subprogramme
%%      nodes-line-2017 = Networking and Services subprogramme
%%

\documentclass[english,twoside,censored,csm,algorithms-track-2020]{HYthesisML}


% In theses, open new chapters only at right page.
% For other types of documents, may ask "openany" in document.
\PassOptionsToClass{openright,twoside,a4paper}{report}
%\PassOptionsToClass{openany,twoside,a4paper}{report}

\usepackage{csquotes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REFERENCES
%% Some notes on bibliography usage and options:
%% natbib -> you can use, e.g., \citep{} or \parencite{} for (Einstein, 1905); with APA \cite -> Einstein, 1905 without ()
%% maxcitenames=2 -> only 2 author names in text citations, if more -> et al. is used
%% maxbibnames=99 as no great need to suppress the biliography list in a thesis
%% for more information see biblatex package documentation, e.g., from https://ctan.org/pkg/biblatex 

%% Reference style: select one 
%% for APA = Harvard style = authoryear -> (Einstein, 1905) use:
\usepackage[style=authoryear,bibstyle=authoryear,backend=biber,natbib=true,maxnames=99,maxcitenames=2,giveninits=true,uniquename=init]{biblatex}
%% for numeric = Vancouver style -> [1] use:
%\usepackage[style=numeric,bibstyle=numeric,backend=biber,natbib=true,maxbibnames=99,giveninits=true,uniquename=init]{biblatex}
%% for alpahbetic -> [Ein05] use:
%\usepackage[style=alphabetic,bibstyle=alphabetic,backend=biber,natbib=true,maxbibnames=99,giveninits=true,uniquename=init]{biblatex}
%

\addbibresource{bibliography.bib}
% in case you want the final delimiter between authors & -> (Einstein & Zweistein, 1905) 
% \renewcommand{\finalnamedelim}{ \& }
% List the authors in the Bibilipgraphy as Lastname F, Familyname G,
\DeclareNameAlias{sortname}{family-given}
% remove the punctuation between author names in Bibliography 
%\renewcommand{\revsdnamepunct}{ }


%% Block of definitions for fonts and packages for picture management.
%% In some systems, the figure packages may not be happy together.
%% Choose the ones you need.

%\usepackage[utf8]{inputenc} % For UTF8 support, in some systems. Use UTF8 when saving your file.

\usepackage{lmodern}         % Font package, again in some systems.
\usepackage{textcomp}        % Package for special symbols
\usepackage[pdftex]{color, graphicx} % For pdf output and jpg/png graphics
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage[pdftex, plainpages=false]{hyperref} % For hyperlinks and pdf metadata
\usepackage{fancyhdr}        % For nicer page headers
\usepackage{tikz}            % For making vector graphics (hard to learn but powerful)
\usepackage{wrapfig}        % For nice text-wrapping figures (use at own discretion)
% Tikz stuff for apas graphs
\usetikzlibrary{positioning,arrows,shapes,automata}
\tikzstyle{gnode} = [circle,minimum size=1cm,fill=blue!20,draw]
\tikzstyle{line} = [line width=0.5,draw]
\tikzstyle{shaded} = [color=blue!30,line width=2mm,draw]
\tikzstyle{shadedf} = [color=blue!25,line width=1.7mm,draw]
\tikzstyle{tnode} = []
\tikzstyle{dotted} = [dashed, line width=0.5, draw]

\usepackage{amsmath, amssymb, amsthm, amsfonts, hyperref} % For better math

\usepackage{algpseudocode} % for pseudocode: provides algorithmic environment
\usepackage{algorithm}     % for pseudocode: enables captioning

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\theoremstyle{definition}
\newtheorem{definition}[equation]{Definition}
\makeatletter
\let\c@equation\c@figure
\makeatother


\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{float}


\singlespacing               %line spacing options; normally use single

\fussy
%\sloppy                      % sloppy and fussy commands can be used to avoid overlong text lines
% if you want to see which lines are too long or have too little stuff, comment out the following lines
% \overfullrule=1mm
% to see more info in the detailed log about under/overfull boxes...
% \showboxbreadth=50 
% \showboxdepth=50



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 2:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Set up personal information for the title page and the abstract form.
%% Replace parameters with your information.
\title{Implementation and benchmarking of Ukkonen 1990 -algorithm}

% TM: Contributors to template editors now listed in the beginning of the file in comments
\author{Arttu Kilpinen}
\date{\today}



% Set supervisors and examiners, use the titles according to the thesis language
% Prof. 
% Dr. or in Finnish toht. or tri or FT, TkT, Ph.D. or in Swedish... 
\supervisors{Assoc Prof.~Simon Puglisi}
\examiners{Prof.~Dunno yet}


\keywords{Implementation, Shortest Common Superstring}
\additionalinformation{\translate{\track}}

%% For seminar reports:
%%\additionalinformation{Name of the seminar}

%% Replace classification terms with the ones that match your work. ACM
%% ACM Digital library provides a taxonomy and a tool for classification
%% in computer science. Use 1-3 paths, and use right arrows between the
%% about three levels in the path; each path requires a new line.

\classification{\protect{\ \\
\  Theory of Computation $\rightarrow$ Design and Analysis of Algorithms  $\rightarrow$ Data Structures Design and Analysis $\rightarrow$ Data Compression  \\
\  Theory of Computation $\rightarrow$ Design and Analysis of Algorithms  $\rightarrow$ Data Structures Design and Analysis $\rightarrow$ Pattern Matching \\
\  Theory of Computation $\rightarrow$ Design and Analysis of Algorithms  $\rightarrow$ Data Structures Design and Analysis $\rightarrow$ Sorting and Searching
}}

%% if you want to quote someone special. You can comment this line out and there will be nothing on the document.
%\quoting{Bachelor's degrees make pretty good placemats if you get them laminated.}{Jeph Jacques}


%% OPTIONAL STEP: Set up properties and metadata for the pdf file that pdfLaTeX makes.
%% Your name, work title, and keywords are recommended.
\hypersetup{
    unicode=true,           % to show non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={},            % title
    pdfauthor={},           % author
    pdfsubject={},          % subject of the document
    pdfcreator={},          % creator of the document
    pdfproducer={pdfLaTeX}, % producer of the document
    pdfkeywords={something} {something else}, % list of keywords for
    pdfnewwindow=true,      % links in new window
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=black,        % color of internal links
    citecolor=black,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

%%-----------------------------------------------------------------------------------

\begin{document}

% Generate title page.
\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 3:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Write your abstract to be positioned here.
%% You can make several abstract pages (if you want it in different languages),
%% but you should also then redefine some of the above parameters in the proper
%% language as well, in between the abstract definitions.

\begin{abstract}

  Abstract here. Last thing to write

\end{abstract}

% Place ToC
\newpage
\mytableofcontents
\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 4: Write the thesis.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Your actual text starts here. You shouldn't mess with the code above the line except
%% to change the parameters. Removing the abstract and ToC commands will mess up stuff.
%%
%% You may wish to include material to avoid browsing the definitions
%% above. Command \include{file} includes the file of name file.tex.
%% As a side effect, subsequent inclusions may force a page break.

% BSc instructions
%\include{bsc_finnish_contents}
%\include{bsc_english_contents}
% MSc instructions
%\include{msc_finnish_contents}
%\include{msc_english_contents}


Puglisin kommentteja:
- Experiments section saattaa paisua aika paljon. Voisi mahdollisesti jakaa useaan kappaleeseen. Esim implementation kohtaa voisi laittaa myös ukkonen kappaleeseen.

Intro ja Conclusions luonnollisella kielellä. Muualla teknistä kamaa.

%%
\chapter{Introduction}~\label{chp-intro}
  vitusti viitteitä ja pelkkää LUONNOLLISTA kieltä. Ei esim määritelmiä!

  \section{Motivation}

  introssa motivaatiossa rlz mainittu mutta myöhemmin teknisesti
  
  alanko or someone mentionet thet it would be interesting to see an implementation

  \section{Related Work}

  related workista oma kappale jos muita vertailuja kuin alanko ja norri. muuten ehkä introon.
  
  \section{Structure of the Thesis}

%%
\chapter {Shortest Common Superstring (preli)}


preliminaries including syntax

what is an approximation algorithm

Maininta aakkostosta?

Tätä voi ehkä jakaa sectioneihin?

The algorithm described in this thesis \\[1in]



In this chapter we define the concepts used in the thesis. These include the concepts related to strings as well as the concept of approximation algorithm
and state automata. The definiton of linear time complexity is also recalled. This chapter contains the explanations in natural languages following a
a corresponding formal definitions. First we define the concepts related to strings followed by ...  \\[1in]



Regardless of the alphabet a string is simply a finite sequence of symbols. The length of the string equals the number of symbols it contains. 

\begin{definition}[\textsc{String}]~\label{def-string}
  
  For an alphabet $\Sigma$ a string $S$ is a finite sequence of symbols  ${s_1\cdots s_n}$ where each symbol $s_i \in \Sigma$.
  The length of the string $S$ denoted by $|S| = n$ is the number of symbols in the string.
  An empty string denoted by $\epsilon$ contains zero symbols.
  
\end{definition}

If a string $S$ contains another string $S'$ we say that the string $S'$ is a substring of a string $S$ and string $S$ is a superstring of $S'$-.
By containing a string we mean that there is a sequence of symbols in $S$ that spells out $S'$

\begin{definition}[\textsc{Substring and Superstring}]~\label{def-sub-super}
  Let there be two strings $S$ and $S'$.
  $S'$ is a substring of $S$ if and only if $S$ can be written as $RS'T$ where $R$ and $T$ are strings. $R$ and $T$ may be empty.
  If $R$ and $T$ are both empty then $S = S'$ which is a substring of itself.
  An empty string is trivially a substring of every other string.\\

  If $S'$ if a substring of $S$ then $S$ is a superstring of $S'$
\end{definition}

If a string contains (I.e. is a superstring) a set of strings, it is said to be a common superstring of the set.

\begin{definition}[\textsc{Common superstring}]~\label{def-cs}

  Let $R = \{S1,...,Sn\}$ be a set of strings and $T$ be a string.
  $T$ is a common superstring of $R$ if and only if $T$ is a superstring for each $Si$ such that $i\in 1,...,n$.
  
\end{definition}

Trivially a common superstring of a set of strings can be constructed by catenating all of the strings of the set together.
This kind of string has a length that equals the lengths of all the substrings added together.

In many cases there exists one or more common superstrings that are shorter than the common superstring produced by this naive methot.

(if there is no overlaps then the naive method yelds the csc ... ref ??)

If a common superstring is a shortest possible it is said to be a shortest common superstring. Finding a shortest common superstring is
an \textsc{NP}-hard problem. 

\begin{definition}[\textsc{Shortest Common Superstring}]~\label{def-scs}

  Let string $T$ be a common superstring of a set of strings $K$.
  $T$ is a shortest common superstring of $K$ if and only if there does not exist a common superstring of $K$ which is shorter than $T$.
  
\end{definition}



%%
\chapter{Ukkonen's Algorithm}

In this chapter we describe the Ukkonen's linear time approximation algorithm for
\textsc{Shortest Common Superstring} problem in detail. First we discuss about the
Aho-Corasic (AC for short) machine as it is used in the algorithm for finding the overlaps
between the set of input keywords. This chapter contains four pseudo code blocks which
essentially forms the algorithm as whole. The algorithms represented here are slightly changed
and contains few corrections from the form they were originally presented. Each such
correction is mentioned and ...

\listofalgorithms


\section{AC-Machine}

%  - mitä tää paska oli alunperin: Laajennettu kmp
%  - äärellinen automaatti poikkeuksin (failure)
%  - pattern matching machine

  
  
%Aho-Corasic machine is a kind of finite state automata 
%Originally the AC-machine was developed for finding \citep{aho75}

  Aho-Corasic machine is a finite state machine like data structure that was developed to be used
  in a pattern matching program to find occurrences of the given keywords in a text string. \citep{aho75}

  The input of such pattern matching program contains a finite set of strings called keywords and an
  arbitrary string called a text string. The output of the program is a list of locations of every
  occurrence of every keyword in a text. The AC-machine data structure and the associated pattern
  matching program was described in \citep{aho75}.

  - similarity with kmp ?

  As the pattern matching part of \citep{aho75} is not used in \citep{ukkonen90} nor it is relevant in
  this thesis, we only discuss the AC-machine as a data structure and omit the pattern matching
  functionality of the original author.

  Formally AC-machine is defined\footnote{\citep{aho75} also defines an output function.
  This is needed only when the AC-machine is used in a pattern matching program.} by the goto function
  $g : \mathbb{N} \times \Sigma \rightarrow \mathbb{N}, g(s_s,c) = s_d$ and the failure function
  $f : \mathbb{N} \rightarrow \mathbb{N}, f(s_s) = s_d$

  The goto function describes the state transition from start state $s_s$ to the destination state
  $s_d$ with the current input symbol $c$ of the state automaton. If there is no such goto transition
  the failure function $f$ is queried and the failure transition from the start state $s_s$ to
  the destination state $s_d$ occurs. The alphabet $\Sigma$ contains every symbol in the set of
  keywords encoded by the AC-machine.

  Let there be a set of keywords $K=\{"baa", "baba" , "abab" , "aab"\}$

  \begin{figure}
  \centering
  \begin{tikzpicture}
%   [scale=.8]

    \node[gnode] (1) at (0,0) {$1$};
    
    \node[gnode, above right = 1cm and 2.277cm of 1] (2) {$2$};
    \node[gnode, right = 2cm of 2] (3) {$3$};
    \node[gnode, above right = 1cm and 2.277cm of 3] (4) {$4$};
    
    \node[gnode, right = 2cm of 3] (5) {$5$};
    \node[gnode, right = 2cm of 5] (6) {$6$};

    \node[gnode, right =  2cm of 1] (7) {$7$};
    \node[gnode, right =  2cm of 7] (8) {$8$};
    \node[gnode, right =  2cm of 8] (9) {$9$};
    \node[gnode, right =  2cm of 9] (10) {$10$};
    
    \node[gnode, below right = 1cm and 2.277cm of 7] (11) {$11$};
    \node[gnode, right = 2cm of 11] (12) {$12$};

    \node[tnode, above left = 2cm and 4.554cm of 1] (v1) {};
    \node[tnode, below left = 2cm and 4.554cm of 1] (v2) {};
    
    \path[->]
    (1) edge node[above] {b} (2)
    (2) edge node[above] {a} (3)
    (3) edge node[above] {a} (4)

    (3) edge node[above] {b} (5)
    (5) edge node[above] {a} (6)

    (1) edge node[above] {a} (7)
    (7) edge node[above] {b} (8)
    (8) edge node[above] {a} (9)
    (9) edge node[above] {b} (10)

    (7) edge[bend right=15] node[above] {a} (11)
    (11) edge node[above] {b} (12);

    \path [->,dashed]
    (3) edge (7)
    (8) edge (2)
    (11) edge[bend right=15] (7)
    
    %%(4) edge (v1) edge (v2) edge (11)
    (5) edge (8)
    (9) edge (3)
    (12) edge (8)
    
    (6) edge (9)
    (10) edge (5);

    \path[line] (4) -- (v1) -- (v2) -- (11);
    

    %% \path[line] (1) -- (2);
    %% \path[line] (2) -- (3);
    %% \path[line] (3) -- (4);

    %% \path[line] (3) -- (5);
    %% \path[line] (5) -- (6);

    %% \path[line] (1) -- (7);
    %% \path[line] (7) -- (8);
    %% \path[line] (8) -- (9);
    %% \path[line] (9) -- (10);

    %% \path[line] (7) -- (11);
    %% \path[line] (11) -- (12);
    

  \end{tikzpicture}
  \caption{An example of a goto function} \label{fig-goto}
\end{figure}


  

  

%   $R=\{S1,...,Sm\}$ 
  \section{Pseudocode}

  %% This declares a command \Comment
  %% The argument will be surrounded by /* ... */
  %% \SetKwComment{Comment}{/* }{ */}

  %% HUOM!!! Kirjoitetaan pseude alkuun sellaisena kuin se on alkuperäisissä papereissa.
  %% Omat indeksöinnit voivat poiketa ja tämä korjataan sitten kun pseudo kirjotietaan
  %% Vastaamaan omaa koodia!
  
  Tänne bugikorjaukset sähköpostista joka lähetetty 30.4
  \begin{algorithm}
    
    \caption{Aho and Corasic Algorithm 2, Construction of the goto function} \label{ac-goto}
    % TODO: Kirjoita omin sanoin input, output, method.
    \hspace*{\algorithmicindent} \textbf{Input:} Set of keywords $K = \{y_1,y_2...,y_k\}$.\\
    \hspace*{\algorithmicindent} \textbf{Output:} Goto function $g$\\
    \hspace*{\algorithmicindent} \textbf{Method:} We assume $g(s,a) = fail$ if $a$ is undefined or if $g(s,a)$ has not yet been defined. The procedure \textit{enter($y$)} inserts into the goto graph a path that spells out $y$
    
      \begin{algorithmic}[1]
        \Function{calculateGotoFunction}{$K = \{y_1,y_2...,y_k\}$}
          % Oma indeksöinti: state 0 on undefined, state 1 = root.
          \State $newstate\gets 0$
          \For{$i \gets 1$ until $k$}
            \State $enter(y_i)$
          \EndFor
          % Oma indeksöinti: state 0 on undefined, state 1 = root.            
          \For{all $a$ s.t. $g(0,a) = fail$ }
            % Oma indeksöinti: state 0 on undefined, state 1 = root.
            \State $g(0,a)\gets 0$
          \EndFor
          %% \If{element is literal}
          %% \Else \Comment{The element is a phrase}
          %% \EndIf
          %% \Return decoded
        \EndFunction

        % Oma indeksöinti alkaa nollasta! a_0 ... a_m -1
        \Function{enter}{$y = (a_1,a_2,...,a_m)$}
          \State $state\gets 0$
          \State $j\gets 1$
          \While{$g(state, a_j) != fail$}
            \State $state\gets g(state,a_j)$
            \State $j\gets j+1$
          \EndWhile
          \For{$p\gets j$ until $m$}
            \State $newstate\gets newstate+1$
            \State $g(state,a_p)\gets newstate$
            \State $state\gets newstate$
          \EndFor
        \EndFunction
      \end{algorithmic}
  \end{algorithm}

  Ja sitten failuren laskeminen

  \begin{algorithm}

    %% TODO: omin sanoin input, output.
    \caption{Aho and Corasix Algorithm 3, Construction of the failure function} \label{ac-fail}
    \hspace*{\algorithmicindent} \textbf{Input:} Goto function $g$ from algorithm\\ % \ref{ac-goto}\\
    \hspace*{\algorithmicindent} \textbf{Output:} Failure function $f$

    \begin{algorithmic}[1]
      \Function{calculateFailureFunction}{$g : \mathbb{N} \rightarrow \mathbb{N}$}
        \State $queue\gets \textit{empty}$
        %% Indeksöinti!
        \For {each $a$ s.t. $g(a,0) = s \neq 0$}
          \State $queue\gets queue \cup \{s\}$
          \State $f(s)\gets 0$
        \EndFor
        \While{$queue \neq empty$}\\
          \hspace*{\algorithmicindent}let $r$ be the next state in $queue$
          \State $queue\gets queue \backslash \{r\}$
          \For{each $a$ s.t. $g(r,a) = s \neq fail$}
            \State $queue\gets queue \cup \{s\}$
            \State $state\gets f(r)$
            \While{$g(state,a) = fail$}
              \State $state\gets f(state)$
            \EndWhile
            \State $f(s)\gets g(state,a)$              
          \EndFor
        \EndWhile
          
      \EndFunction

    \end{algorithmic}
  \end{algorithm}


  \begin{algorithm}

    %% OMIN SANOIN
    \caption{Ukkonen90 algorithm 1, preprocessing} \label{ukk-pre}
    \hspace*{\algorithmicindent} \textbf{Input:} Set $R=\{x_1,...,x_m\}$ of strings, and the goto function $g$ and the failure function $f$ for $R$.\\
    \hspace*{\algorithmicindent} \textbf{Output:} Depth $d(s)$, list $L(s)$ and link $b(s)$ for each state $s$ of the AC machine; Pointer $B$ to the first state in the $b$-link chain; state $F(i)$ representing string $x_i$ for each $x_i$ with the exception that if $x_i$ is a substring of another string in $R$ then $F(i) = 0$.\\
    \hspace*{\algorithmicindent} \textbf{Notation:} operator $\cdot$ denotes list catenation. An inverse of $F$ is represented by $E$: if $F(i) = s$ then $E(s) = i$; initially $E(s) = 0$ for every state s.\\
    
    \begin{algorithmic}[1]
      \Function{calculateAuxiliaryFunctions}{$g : \mathbb{N} \rightarrow \mathbb{N}$, $f : \mathbb{N} \rightarrow \mathbb{N}$}
        \For {$i = 1,...,m$}
          \hspace*{\algorithmicindent} let $x_i = a_1,...,a_k$
          \State $s\gets 0$
          \For {$j = 1,...,k$}
            \State $s\gets g(s,a_j)$
            \State $L(s)\gets L(s) \cdot \{j\}$
            \If {$j = k$}
              \State $F(i)\gets s$
              \State $E(s)\gets i$
              \If {$s$ is not a leaf of the AC machine}
                \State $F(i)\gets 0)$
              \EndIf
            \EndIf
          \EndFor
        \EndFor
        \State $queue\gets 0$
        \State $d(0)\gets 0$
        \State $B\gets 0$
        \While{$queue\neq empty$}
          \hspace*{\algorithmicindent} let $r$ be the next state in queue
          \State $queue\gets queue \backslash \{r\}$
          \For {each $s$ s.t. $g(r,a) = s$ for some $a$}
            \State $queue\gets queue\cdot s$
            \State $d(s)\gets d(r)+1$
            \State $b(s)\gets B$
            \State $F(E(f(s)))\gets 0$
          \EndFor
        \EndWhile
      \EndFunction
        
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}
    %% TODO: omin sanoin input, output.
    \caption{Ukkonen90 Algorithm 2 Construction of H} \label{ukk-h}
    \hspace*{\algorithmicindent} \textbf{Input:} Augmented AC machine for $R$ as constructed by ref\\ %ref?
    \hspace*{\algorithmicindent} \textbf{Output:} A Hamiltonian path $H$ in the overlap graph of reduced $R$. A common superstring for $R$ can then be constructed by forming $p(H)$.\\

    \begin{algorithmic}[1]
      \Function{createPath}{Outputs of the previous functions, Set of keywords $R = \{k_1,...,k_m\}$}
        \For {$j = 1,...,m$}
          \If {$F(j)\neq 0$}
            \State $P(f(F(j)))\gets P(f(F(j)))\cdot {j}$
            \State $FIRST(j)\gets j$
            \State $LAST(j)\gets j$
          \Else
            \State $forbidden(j)\gets true$
          \EndIf
        \EndFor  
        \State $s\gets b(B)$
        \While {$s\neq 0$}
          \If {$P(s)$ is not empty}
            \For {each $j$ in $L(s)$ s.t. $forbidden(j) = false$}
              \State $i\gets$ the first element of $P(s)$
              \If {$FIRST(i) = j)$}
                \If {$P(s)$ has only one element}
                  \hspace*{\algorithmicindent} \textbf{goto} \textit{next}
                \Else
                  \State $i\gets$ the second element of $P(s)$
                \EndIf
              \EndIf  
            \State $H\gets H\cdot \{(x_i,x_j)\}$
            \State $forbidden(j)\gets true$
            \State $FIRST(LAST(j))\gets FIRST(i)$
            \State $LAST(FIRST(i))\gets LAST(j)$
            \hspace*{\algorithmicindent} \textit{next:}
            \EndFor
          \State $P(f(s))\gets P(f(s))\cdot P(s)$
          \EndIf
          \State $s\gets b(s)$
        \EndWhile
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
  


  \section{correctness}
  

  approx factor (ei välttämättä epsilon mutta jotkut boundit on olemassa ainakin kompressiolle)

%%
\chapter{Relative Lempel-Ziv}

  Lempel-Ziv dictionary construction.

  subsections?

%%
\chapter{experiments}

  \section{Implementation}

  \section{Benchmark Data}
  HW + instances

  \section{Results}

  \section{Discussion}

%
\chapter{Conclusions}
  

  \begin{enumerate}
  \item \citep{aho75} describes the Aho-Corasic machine for the first time. It gives the pseudocode to creation and search.
  \item alanko dissertation, no bibtex yet. Discusses some things related to this topic.
  \item \citep{alanko17} describes approx scs algorithm for compact space.
  \item statistics.pdf desccribes the dataset pizzachili.
  \item \citep{ukkonen90} is the most important reference in this thesis. Describes the main scs algorithm.
  \item \citep{tarhio88} Describes the same algorithm as ukkonen 90 but not in linear time.
  \end{enumerate}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage                          %fixes the position of bibliography in bookmarks
\phantomsection
\addcontentsline{toc}{chapter}{\bibname}  % This lines adds the bibliography to the ToC
\printbibliography

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter

%
% TARVIINKO APPENDICES??
%
%

\begin{appendices}

%\input{instructions_english}
%% \input{instructions_finnish}

%% \appendix{Sample Appendix\label{appendix:model}}
%% usually starts on its own page, with the name and number of the appendix at the top. 
%% The appendices here are just models of the table of contents and the presentation. Each appendix
%% Each appendix is paginated separately.

%% In addition to complementing the main document, each appendix is also its own, independent entity.
%% This means that an appendix cannot be just an image or a piece of programming, but the appendix must explain its contents and meaning.

\end{appendices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
