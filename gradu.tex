%% History:
%% December 2020 Veli Mäkinen removed obsolete options related to 40 cr theses
%% May 2019 Tomi Männistö, Antti-Pekka Tuovinen proofreading; 30 vs. 40 cr theses, etc.
%% May 2019 Tomi Männistö changed from babelbib to bibtex; Abstract page (and other pages as well) reformatting.
%% January–May 2019 several issues fixed by Niko Mäkitalo; long fields in abstract
%% March 2018 template file extended by Lea Kutvonen to exploit HYthesisML.cls.
%% Feb2018 This template file for the use of HYgraduML.cls was  modified by Veli Mäkinen from HY_fysiikka_LuKtemplate.tex
%% authored by Roope Halonen ja Tomi Vainio in 2017.
%% Some text is also inherited from engl_malli.tex versions by Kutvonen, Erkiö, Mäkelä, Verkamo, Kurhila, and
%% Nykänen, to accompany tktltiki.cls (by Puolakka 2002).


%% Follow comments to support use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 1: Choose options for MSc / BSc / seminar layout and your bibliographic style
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  Language: 
%%      finnish, swedish, or english
%%  Pagination (use twoside by default)  
%%      oneside or twoside,
%%  Study programme / kind of report
%%      csm  = Master's thesis in Computer Science Master's Programme;
%%      tkt = Bachelor's thesis in Computer Science Bachelor's Programme;
%%      seminar = seminar report
%%  For Master's thesis choose your line or track:
%%      (30 cr thesis, 2020 onwards, Master's Programme in Computer Science = csm)
%%      software-track-2020 = Software study track
%%      algorithms-track-2020 = Algorithms study track
%%      networking-track-2020 = Networking study track
%%
%%      (30 cr thesis, Master's Programme in Computer Science = csm)
%%      sw-track-2018 = Software Systems study track
%%      alko-track-2018 = Algorithms study track
%%      nodes-track-2018 = Networking and Services study track
%%
%%      (30 cr thesis, Master's Programme in Computer Science = csm)
%%      sw-line-2017 =  Software systems subprogramme
%%      alko-line-2017 = Algorithms, Data Analytics and Machine Learning subprogramme
%%      bio-line-2017 = Algorithmic Bioinformatics subprogramme
%%      nodes-line-2017 = Networking and Services subprogramme
%%

\documentclass[english,twoside,censored,csm,algorithms-track-2020]{HYthesisML}


% In theses, open new chapters only at right page.
% For other types of documents, may ask "openany" in document.
\PassOptionsToClass{openright,twoside,a4paper}{report}
%\PassOptionsToClass{openany,twoside,a4paper}{report}

\usepackage{csquotes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REFERENCES
%% Some notes on bibliography usage and options:
%% natbib -> you can use, e.g., \citep{} or \parencite{} for (Einstein, 1905); with APA \cite -> Einstein, 1905 without ()
%% maxcitenames=2 -> only 2 author names in text citations, if more -> et al. is used
%% maxbibnames=99 as no great need to suppress the biliography list in a thesis
%% for more information see biblatex package documentation, e.g., from https://ctan.org/pkg/biblatex 

%% Reference style: select one 
%% for APA = Harvard style = authoryear -> (Einstein, 1905) use:
\usepackage[style=authoryear,bibstyle=authoryear,backend=biber,natbib=true,maxnames=99,maxcitenames=2,giveninits=true,uniquename=init]{biblatex}
%% for numeric = Vancouver style -> [1] use:
%\usepackage[style=numeric,bibstyle=numeric,backend=biber,natbib=true,maxbibnames=99,giveninits=true,uniquename=init]{biblatex}
%% for alpahbetic -> [Ein05] use:
%\usepackage[style=alphabetic,bibstyle=alphabetic,backend=biber,natbib=true,maxbibnames=99,giveninits=true,uniquename=init]{biblatex}
%

\addbibresource{bibliography.bib}
% in case you want the final delimiter between authors & -> (Einstein & Zweistein, 1905) 
% \renewcommand{\finalnamedelim}{ \& }
% List the authors in the Bibilipgraphy as Lastname F, Familyname G,
\DeclareNameAlias{sortname}{family-given}
% remove the punctuation between author names in Bibliography 
%\renewcommand{\revsdnamepunct}{ }


%% Block of definitions for fonts and packages for picture management.
%% In some systems, the figure packages may not be happy together.
%% Choose the ones you need.

%\usepackage[utf8]{inputenc} % For UTF8 support, in some systems. Use UTF8 when saving your file.

\usepackage{lmodern}         % Font package, again in some systems.
\usepackage{textcomp}        % Package for special symbols
\usepackage[pdftex]{color, graphicx} % For pdf output and jpg/png graphics
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage[pdftex, plainpages=false]{hyperref} % For hyperlinks and pdf metadata
\usepackage{fancyhdr}        % For nicer page headers
\usepackage{tikz}            % For making vector graphics (hard to learn but powerful)
\usepackage{wrapfig}        % For nice text-wrapping figures (use at own discretion)
% Tikz stuff for apas graphs
\usetikzlibrary{positioning,arrows,shapes,automata}
\tikzstyle{gnode} = [circle,minimum size=1cm,fill=blue!20,draw]
\tikzstyle{line} = [line width=0.5,draw]
\tikzstyle{shaded} = [color=blue!30,line width=2mm,draw]
\tikzstyle{shadedf} = [color=blue!25,line width=1.7mm,draw]
\tikzstyle{tnode} = [minimum size=0.67cm]
\tikzstyle{enode} = [minimum size=0.01cm]
\tikzstyle{dotted} = [dashed, line width=0.4, draw]

\usepackage{amsmath, amssymb, amsthm, amsfonts, hyperref} % For better math

\usepackage{algpseudocode} % for pseudocode: provides algorithmic environment
\usepackage{algorithm}     % for pseudocode: enables captioning

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\theoremstyle{definition}
\newtheorem{definition}[equation]{Definition}
\makeatletter
\let\c@equation\c@figure
\makeatother


\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{float}


\singlespacing               %line spacing options; normally use single

\fussy
%\sloppy                      % sloppy and fussy commands can be used to avoid overlong text lines
% if you want to see which lines are too long or have too little stuff, comment out the following lines
% \overfullrule=1mm
% to see more info in the detailed log about under/overfull boxes...
% \showboxbreadth=50 
% \showboxdepth=50



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 2:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Set up personal information for the title page and the abstract form.
%% Replace parameters with your information.
\title{Implementation and benchmarking of Ukkonen 1990 -algorithm}

% TM: Contributors to template editors now listed in the beginning of the file in comments
\author{Arttu Kilpinen}
\date{\today}



% Set supervisors and examiners, use the titles according to the thesis language
% Prof. 
% Dr. or in Finnish toht. or tri or FT, TkT, Ph.D. or in Swedish... 
\supervisors{Assoc Prof.~Simon Puglisi}
\examiners{Prof.~Dunno yet}


\keywords{Implementation, Shortest Common Superstring}
\additionalinformation{\translate{\track}}

%% For seminar reports:
%%\additionalinformation{Name of the seminar}

%% Replace classification terms with the ones that match your work. ACM
%% ACM Digital library provides a taxonomy and a tool for classification
%% in computer science. Use 1-3 paths, and use right arrows between the
%% about three levels in the path; each path requires a new line.

\classification{\protect{\ \\
\  Theory of Computation $\rightarrow$ Design and Analysis of Algorithms  $\rightarrow$ Data Structures Design and Analysis $\rightarrow$ Data Compression  \\
\  Theory of Computation $\rightarrow$ Design and Analysis of Algorithms  $\rightarrow$ Data Structures Design and Analysis $\rightarrow$ Pattern Matching \\
\  Theory of Computation $\rightarrow$ Design and Analysis of Algorithms  $\rightarrow$ Data Structures Design and Analysis $\rightarrow$ Sorting and Searching
}}

%% if you want to quote someone special. You can comment this line out and there will be nothing on the document.
%\quoting{Bachelor's degrees make pretty good placemats if you get them laminated.}{Jeph Jacques}


%% OPTIONAL STEP: Set up properties and metadata for the pdf file that pdfLaTeX makes.
%% Your name, work title, and keywords are recommended.
\hypersetup{
    unicode=true,           % to show non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={},            % title
    pdfauthor={},           % author
    pdfsubject={},          % subject of the document
    pdfcreator={},          % creator of the document
    pdfproducer={pdfLaTeX}, % producer of the document
    pdfkeywords={something} {something else}, % list of keywords for
    pdfnewwindow=true,      % links in new window
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=black,        % color of internal links
    citecolor=black,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

%%-----------------------------------------------------------------------------------

\begin{document}

% Generate title page.
\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 3:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Write your abstract to be positioned here.
%% You can make several abstract pages (if you want it in different languages),
%% but you should also then redefine some of the above parameters in the proper
%% language as well, in between the abstract definitions.

\begin{abstract}

  Abstract here. Last thing to write

\end{abstract}

% Place ToC
\newpage
\mytableofcontents
\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STEP 4: Write the thesis.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Your actual text starts here. You shouldn't mess with the code above the line except
%% to change the parameters. Removing the abstract and ToC commands will mess up stuff.
%%
%% You may wish to include material to avoid browsing the definitions
%% above. Command \include{file} includes the file of name file.tex.
%% As a side effect, subsequent inclusions may force a page break.

% BSc instructions
%\include{bsc_finnish_contents}
%\include{bsc_english_contents}
% MSc instructions
%\include{msc_finnish_contents}
%\include{msc_english_contents}


Puglisin kommentteja:
- Experiments section saattaa paisua aika paljon. Voisi mahdollisesti jakaa useaan kappaleeseen. Esim implementation kohtaa voisi laittaa myös ukkonen kappaleeseen.

Intro ja Conclusions luonnollisella kielellä. Muualla teknistä kamaa.

%% ei kappalejakoa introon. sectionit pois.
\chapter{Introduction}~\label{chp-intro}
  vitusti viitteitä ja pelkkää LUONNOLLISTA kieltä. Ei esim määritelmiä!

  \section{Motivation}

  - scs yleisesti datan pakkaamiseen
  - molekyylibiologia sekvensointi vaikeaa pitkälle pätkälle
    - molekyylin pilkkominen random paloiksi, sekvensointi ja superstringin ottaminen.
      saadaan approksimaatio alkuperäisestä pitkästä sekvenssistä
    - toimii käutännössä hyvin \citep{Peltola83}
  

  introssa motivaatiossa rlz mainittu mutta myöhemmin teknisesti
  
  alanko or someone mentionet thet it would be interesting to see an implementation

  \section{Related Work}

  O(nm) based algorithm based on KnuthMorrisPratt \citep{Knuth77} \citep{Tarhio88}
  perustuu kaikkien overlap parien laskemiseen kmp:llä.

  hae jostain tietokannasta approx scs algoja !

  related workista oma kappale jos muita vertailuja kuin alanko ja norri. muuten ehkä introon.
  
  \section{Structure of the Thesis}

%%
\chapter {Shortest Common Superstring (preli)}


preliminaries including syntax

what is an approximation algorithm

Maininta aakkostosta?

Tätä voi ehkä jakaa sectioneihin?

The algorithm described in this thesis \\[1in]



In this chapter we define the concepts used in the thesis. These include the concepts related to strings as well as the concept of approximation algorithm
and state automata. The definiton of linear time complexity is also recalled. This chapter contains the explanations in natural languages following a
a corresponding formal definitions. First we define the concepts related to strings followed by ...  \\[1in]



Regardless of the alphabet a string is simply a finite sequence of symbols. The length of the string equals the number of symbols it contains. 

\begin{definition}[\textsc{String}]~\label{def-string}
  
  For an alphabet $\Sigma$ a string $S$ is a finite sequence of symbols  ${s_1\cdots s_n}$ where each symbol $s_i \in \Sigma$.
  The length of the string $S$ denoted by $|S| = n$ is the number of symbols in the string.
  An empty string denoted by $\epsilon$ contains zero symbols.
  
\end{definition}

If a string $S$ contains another string $S'$ we say that the string $S'$ is a substring of a string $S$ and string $S$ is a superstring of $S'$.
By containing a string we mean that there is a sequence of symbols in $S$ that spells out $S'$

\begin{definition}[\textsc{Substring and Superstring}]~\label{def-sub-super}
  Let there be two strings $S$ and $S'$.
  $S'$ is a substring of $S$ if and only if $S$ can be written as $RS'T$ where $R$ and $T$ are strings. $R$ and $T$ may be empty.
  If $R$ and $T$ are both empty then $S = S'$ which is a substring of itself.
  An empty string is trivially a substring of every other string.\\

  If $S'$ if a substring of $S$ then $S$ is a superstring of $S'$
\end{definition}

If a string contains (I.e. is a superstring) a set of strings, it is said to be a common superstring of the set.

\begin{definition}[\textsc{Common superstring}]~\label{def-cs}

  Let $R = \{S1,...,Sn\}$ be a set of strings and $T$ be a string.
  $T$ is a common superstring of $R$ if and only if $T$ is a superstring for each $Si$ such that $i\in 1,...,n$.
  
\end{definition}

Trivially a common superstring of a set of strings can be constructed by catenating all of the strings of the set together.
This kind of string has a length that equals the lengths of all the substrings added together.

In many cases there exists one or more common superstrings that are shorter than the common superstring produced by this naive methot.

(if there is no overlaps then the naive method yelds the csc ... ref ??)

If a common superstring is a shortest possible it is said to be a shortest common superstring. Finding a shortest common superstring is
an \textsc{NP}-hard problem. 

\begin{definition}[\textsc{Shortest Common Superstring}]~\label{def-scs}

  Let string $T$ be a common superstring of a set of strings $K$.
  $T$ is a shortest common superstring of $K$ if and only if there does not exist a common superstring of $K$ which is shorter than $T$.
  
\end{definition}

% Tarhio88
Since the decision version of this problem is NP-complete... \citep{Garey79}

-Lemma: Jos x on y:n substring s.t. y kuuluu R niin scs(R) == scs(Rux)
todistus ???

definition: reduced set of strings = joukko stringejä joissa mikään string ei ole toisen substring.

definition: overlap note this is not symmetric!
maximal overlap.


%%
\chapter{Ukkonen's Algorithm}

In this chapter we describe the Ukkonen's linear time approximation algorithm for
\textsc{Shortest Common Superstring} problem in detail. First we discuss about the
Aho-Corasic (AC for short) machine as it is used in the algorithm for finding the overlaps
between the set of input keywords. This chapter contains four pseudo code blocks which
essentially forms the algorithm as whole. The algorithms represented here are slightly changed
and contains few corrections from the form they were originally presented. Each such
correction is mentioned and ...

\listofalgorithms

\section{The Greedy Heuristic}

Let there be a set of strings $R=\{S1,...,Sm\}$. A naive method for constructing a common superstring is
to concatenate all the strings in the set. For the set $R$ the resulting superstring is $S1S2\cdots Sm$.
Since our goal is to achieve an approximation of the shortest common superstring the following heuristic
is used.

\begin{enumerate}
\item Examine the set and remove the two strings $S_i$ and $S_j$ that have the longest overlap among all pairs of strings $(S_i, S_j)$ s.t. $i\neq j$. Note that the longest overlap may be an empty string. If there are multiple pairs of strings with the longest overlap, the decision can be made arbitrarily.
\item Merge the strings together such that they are maximally overlapped to form a shortest common superstring of the set $\{S_i, S_j\}$.
  \item Add the new string back to the set $R$ and repeat until there is only one string left.
\end{enumerate}

It turns out that the \textsc{Shortest Common Superstring} problem is analogyous with a special case of
the \textsc{Longest Hamiltonian Path} problem, that is, when the set of strings is converted into
a weighted complete digraph as follows. Lets construct a graph $G_R=(V_R,E_R)$ from the set of strings $R$.
Let there be a vertex $v_i\in V_R$ for each string $S_i\in R$. Moreover, we define the start node and
the end node $\{V_{start},V_{end}\}\in V_R$. Each vertex have a directed weighted edge to each other
such that the weight $(V_{start}, V_i) = 0$ and the weight $(V_i, V_{end}) = 0$ for all $i=1,...,m$.
The weight of every other edge $(V_i, V_j)$ is the length of the maximum overlap between $S_i$ and $S_j$.
TODO: korjaa. vain $V_i$ osa graafia on complete.

%-intro hamiltonian pathiin!

%-special case of shortest hampath in weighted directed graph.

%- graafin nodet keywordeja SEKÄ alku ja loppunode

%- graafin kaarten painot maksimaalisia overlappeja



Since the overlap graph is a complete graph, there certainly exists a hamiltonian path(s). Taken by any
of the hamiltonian paths $H$ from the graph $G_R$, we can construct a common superstring of $R$ by
removing the overlaps and catenating the strings representing the nodes in the same order they appear
on the path.
...
Lets take the strings in the same order as their corresponding nodes appear in the path $H$. Put the
strings above each other such that they are maximally overlapped. The projection $p(H)$ results as a
superstring of $R$.

\begin{figure}
\centering
\begin{tikzpicture}
  
  \node[enode] (H1) at (0,0) {};
  \node[enode] (H2) at (14,0) {};
  \path [|-|] (H1) edge node[below] {p(H)} (H2);

  \node[enode, above = 0.5cm of H1] (S1a) {};
  \node[enode, above right = 0.5cm and 3.3cm of H1] (S1b) {};
  \path[|-|] (S1a) edge (S1b);
  \node[enode, right = 0cm of S1b] (S1txt) {$S_1$};

  \node[enode, above right = 0.5cm and 1.2cm of S1a] (S2a) {};
  \node[enode, right = 2.6cm of S2a] (S2b) {};
  \path[|-|] (S2a) edge (S2b);
  \node[enode, right = 0cm of S2b] (S2txt) {$S_2$};
  
  \node[enode, above right = 0.5cm and 2cm of S2a] (S3a) {};
  \node[enode, right = 2.6cm of S3a] (S3b) {};
  \path[|-|] (S3a) edge (S3b);
  \node[enode, right = 0cm of S3b] (S3txt) {$S_3$};

  \node[tnode, rotate = 40, above = 0.2cm of S3b] (dots1) {...};

  \node[enode, above right = 1cm and 2.2cm of S3a] (Sia) {};
  \node[enode, right = 2.6cm of Sia] (Sib) {};
  \path[|-|] (Sia) edge (Sib);
  \node[enode, right = 0cm of Sib] (Sitxt) {$S_i$};

  \node[enode, above right = 0.5cm and 1.2cm of Sia] (Si1a) {};
  \node[enode, right = 2.6cm of Si1a] (Si1b) {};
  \path[|-|] (Si1a) edge (Si1b);
  \node[enode, right = 0cm of Si1b] (Sitxt) {$S_{i+1}$};

  \node[enode, above = 0.1cm of Sia] (zc) {};
  \node[enode, below = 0.1cm of Si1a] (za) {};
  \node[enode, above = 0.1cm of Sib] (zb) {};

  \path[|-|, shorten >= -0.3cm] (zc) edge node[right = -0.1cm,fill=white,align=center] {$u_i$} (za);
  \path[|-|] (za) edge node[fill=white,align=center] {$v_i$} (zb);

  \node[tnode, rotate = 35, above = 0.2cm of Si1b] (dots2) {...};

  \node[enode, above right = 1cm and 2.2cm of Si1a] (Sma) {};
  \node[enode, right = 3.455cm of Sma] (Smb) {};
  \path[|-|] (Sma) edge (Smb);
  \node[enode, right = 0cm of Smb] (Sitxt) {$S_m$};  
  
\end{tikzpicture}
\caption{The projection $p(H)$ of the set of strings $\{s_1,...,s_m\}}
\end{figure}


  analogia: hampathi tällaisessa overlap graphissa: path = nodejen järjestys.
  -> laita stringit  (nodet) päällekkäin maksimaalisen overlapin perusteella ja "mergeä ne".
  "projektio" tästä tuloksena on common superstring. koska kaaren painot kuvaavat overlappia eli kompressiota
  niin oikea scs on tämän verkon lyhin hampathi. ahne heuristiikka kuitenkin antaa usein jonkin
  muun ratkaisun.

  -projektion pituus = superstringin pituus = kaikkien keywordien pituus - overlappien pituus, jossa
  overlappien pituus on kompressio. näinollen pisin CS tarkoittaa pienintä kompressiota ja päinvastoin.

  TÄHÄN KUVA!

  koska projektion p(H) sekä common superstringin konstruointi on analogisesti ekvivalenttia niin lyhin
  projektio tarkoittaa lyhintä common superstringiä.

  Lemma2.2: kuvan mukaan suurin overlap xi ja xi+1 välillä on ui.
  todistus


  theorem 2.3 CONCEPTUALLY the same thing.
  conclusion for the analogy: SCS for R is an string p(H) where H is a longest hampiltonina path from the start node to the end node in the overlap graph for R.

  DEF greedy heuristic for hampath analogy. tarhio sivu 134.

  ongelma ahneessa heuristiikassa on että voi tehdä hyvän valinnan joka pakottaa myöhemmin huonoihin valintoihin.

  CONCEPTUALLY the ukkonen algo does just that so the proofs apply.



  
ennen tätä maininta approksimaatioalgosta. koska np niin käytetään approksimaatiota ja tätä heuristiikkaa


-määrittele kompressio

-scsn kompressio on vähintään puolet optimaalisesta \citep{Tarhio88}


  %% tarhio99
We show that $(n-k)\geq \frac{1}{2}(n-k_{min})$ where  $k_{min}$ is the length of a shortest common superstring. Hence the compression achieved by the algorithm is at least half of the maximum compression. It also seems that the lengths always satisfy $k\leq 2k_{min}$ but proving this remains open.
Tämä boundi todistettu käyttäen hampathia paperissa \citep{Tarhio88}.
Todistus pitkä ja monimutkainen, ei käydä nyt läpi. 

  approx factor (ei välttämättä epsilon mutta jotkut boundit on olemassa ainakin kompressiolle)



\section{AC-Machine}

%  - mitä tää paska oli alunperin: Laajennettu kmp
%  - äärellinen automaatti poikkeuksin (failure)
%  - pattern matching machine

% Ei yhden rivin kappaleita!  
  
  Aho-Corasic machine is a finite state machine like data structure that was developed to be used
  in a pattern matching program to find occurrences of the given keywords in a text string. \citep{aho75}

  The input of such pattern matching program contains a finite set of strings called keywords and an
  arbitrary string called a text string. The output of the program is a list of locations of every
  occurrence of every keyword in a text. The AC-machine data structure and the associated pattern
  matching program was described in \citep{aho75}.

  - similarity with kmp ?

  % Tulee fiilis etten tiedä mistä puhun. Kerro vähän enemmän tähän kappaleeseen  
  As the pattern matching part of \citep{aho75} is not used in \citep{ukkonen90} nor it is relevant in
  this thesis, we only discuss the AC-machine as a data structure and omit the pattern matching
  functionality of the original author.


  Formally AC-machine is defined\footnote{\citep{aho75} also defines an output function.
  This is needed only when the AC-machine is used in a pattern matching program.} by the goto function
  $g : \mathbb{N} \times \Sigma \rightarrow \mathbb{N}, g(s_s,c) = s_d$ and the failure function
  $f : \mathbb{N} \rightarrow \mathbb{N}, f(s_s) = s_d$

  % ei ukkosen algoritmissa ole mitään current input symbolia.. pitää muotoilla eritavalla.
  The goto function describes the state transition from start state $s_s$ to the destination state
  $s_d$ with the current input symbol $c$ of the state automaton. If there is no such goto transition
  the failure function $f$ is queried and the failure transition from the start state $s_s$ to
  the destination state $s_d$ occurs. The alphabet $\Sigma$ contains every symbol in the set of
  keywords encoded by the AC-machine.

  To construct the AC-machine for the set of keywords the \textsc{FSA} like goto function is first
  created. The goto function is then used to construct the failure function which completes the
  construction of the AC-machine. The goto function can be thought of as a trie. 
  I.e it is a rooted tree 
  root node and the nodes that spells out some strings. 

  The algorithms \ref{ac-goto} and \ref{ac-fail} are used as a complete definitons of the goto and
  failure functions.

  Let there be a set of keywords $K=\{$"baa", "baba" , "abab" , "aab"$\}$. 

  Can produce "aababaa" (scs with compression 14-7=7) or "baababab" with compression 14-8 = 6.


  \begin{figure}
  \centering
  \begin{tikzpicture}
%   [scale=.8]

    \node[gnode] (1) at (0,0) {$1$};
    
    \node[gnode, above right = 1cm and 2.277cm of 1] (2) {$2$};
    \node[gnode, right = 2cm of 2] (3) {$3$};
    \node[gnode, above right = 1cm and 2.277cm of 3] (4) {$4$};
    
    \node[gnode, right = 2cm of 3] (5) {$5$};
    \node[gnode, right = 2cm of 5] (6) {$6$};

    \node[gnode, right =  2cm of 1] (7) {$7$};
    \node[gnode, right =  2cm of 7] (8) {$8$};
    \node[gnode, right =  2cm of 8] (9) {$9$};
    \node[gnode, right =  2cm of 9] (10) {$10$};
    
    \node[gnode, below right = 1cm and 2.277cm of 7] (11) {$11$};
    \node[gnode, right = 2cm of 11] (12) {$12$};

    \node[tnode, above left = 2.725cm and 2.277cm of 1] (v1) {};
    \node[tnode, below left = 1cm and 2.277 of 1] (v2) {};
    
    \path[->]
    (1) edge[loop,in=110,out=190,distance=3cm] node[below right,align=center] {$\neg \{a,b\}$} (1)
    
    (1) edge[bend left=15] node[above] {b} (2)
    (2) edge node[above] {a} (3)
    (3) edge node[above] {a} (4)

    (3) edge node[above] {b} (5)
    (5) edge node[above] {a} (6)

    (1) edge[bend right=15] node[above] {a} (7)
    (7) edge node[above] {b} (8)
    (8) edge node[above] {a} (9)
    (9) edge node[above] {b} (10)

    (7) edge[bend right=15] node[above] {a} (11)
    (11) edge node[above] {b} (12);

    \path [->,dotted]

    (2) edge[bend left=15] (1)
    (7) edge [bend right=15] (1)
    
    (3) edge (7)
    (8) edge (2)
    (11) edge[bend right=15] (7)
    
    %%(4) edge (v1) edge (v2) edge (11)
    (5) edge (8)
    (9) edge (3)
    (12) edge (8)
    
    (6) edge (9)
    (10) edge (5);

    \path[->,dotted,rounded corners, shorten <= 0.5cm, shorten >= 0.5cm] plot coordinates {(4) (v1) (v2) (11)};
    % repaint these nodes
    \node[gnode, above right = 1cm and 2.277cm of 3] (4) {$4$};
    \node[gnode, below right = 1cm and 2.277cm of 7] (11) {$11$};
    

  \end{tikzpicture}
  \caption{An example of an AC-machine. TODO: 4->11 arrow head is missing.} \label{fig-goto}
\end{figure}


  

  

%   $R=\{S1,...,Sm\}$ 
  \section{Pseudocode}

  %% This declares a command \Comment
  %% The argument will be surrounded by /* ... */
  %% \SetKwComment{Comment}{/* }{ */}

  %% HUOM!!! Kirjoitetaan pseude alkuun sellaisena kuin se on alkuperäisissä papereissa.
  %% Omat indeksöinnit voivat poiketa ja tämä korjataan sitten kun pseudo kirjotietaan
  %% Vastaamaan omaa koodia!
  
  Tänne bugikorjaukset sähköpostista joka lähetetty 30.4
  \begin{algorithm}
    
    \caption{Aho and Corasic Algorithm 2, Construction of the goto function} \label{ac-goto}
    % TODO: Kirjoita omin sanoin input, output, method.
    \hspace*{\algorithmicindent} \textbf{Input:} Set of keywords $K = \{y_1,y_2...,y_k\}$.\\
    \hspace*{\algorithmicindent} \textbf{Output:} Goto function $g$\\
    \hspace*{\algorithmicindent} \textbf{Method:} We assume $g(s,a) = fail$ if $a$ is undefined or if $g(s,a)$ has not yet been defined. The procedure \textit{enter($y$)} inserts into the goto graph a path that spells out $y$
    
      \begin{algorithmic}[1]
        \Function{calculateGotoFunction}{$K = \{y_1,y_2...,y_k\}$}
          % Oma indeksöinti: state 0 on undefined, state 1 = root.
          \State $newstate\gets 0$
          \For{$i \gets 1$ until $k$}
            \State $enter(y_i)$
          \EndFor
          % Oma indeksöinti: state 0 on undefined, state 1 = root.            
          \For{all $a$ s.t. $g(0,a) = fail$ }
            % Oma indeksöinti: state 0 on undefined, state 1 = root.
            \State $g(0,a)\gets 0$
          \EndFor
          %% \If{element is literal}
          %% \Else \Comment{The element is a phrase}
          %% \EndIf
          %% \Return decoded
        \EndFunction

        % Oma indeksöinti alkaa nollasta! a_0 ... a_m -1
        \Function{enter}{$y = (a_1,a_2,...,a_m)$}
          \State $state\gets 0$
          \State $j\gets 1$
          \While{$g(state, a_j) != fail$}
            \State $state\gets g(state,a_j)$
            \State $j\gets j+1$
          \EndWhile
          \For{$p\gets j$ until $m$}
            \State $newstate\gets newstate+1$
            \State $g(state,a_p)\gets newstate$
            \State $state\gets newstate$
          \EndFor
        \EndFunction
      \end{algorithmic}
  \end{algorithm}

  Ja sitten failuren laskeminen

  \begin{algorithm}

    %% TODO: omin sanoin input, output.
    \caption{Aho and Corasix Algorithm 3, Construction of the failure function} \label{ac-fail}
    \hspace*{\algorithmicindent} \textbf{Input:} Goto function $g$ from algorithm\\ % \ref{ac-goto}\\
    \hspace*{\algorithmicindent} \textbf{Output:} Failure function $f$

    \begin{algorithmic}[1]
      \Function{calculateFailureFunction}{$g : \mathbb{N} \rightarrow \mathbb{N}$}
        \State $queue\gets \textit{empty}$
        %% Indeksöinti!
        \For {each $a$ s.t. $g(a,0) = s \neq 0$}
          \State $queue\gets queue \cup \{s\}$
          \State $f(s)\gets 0$
        \EndFor
        \While{$queue \neq empty$}\\
          \hspace*{\algorithmicindent}let $r$ be the next state in $queue$
          \State $queue\gets queue \backslash \{r\}$
          \For{each $a$ s.t. $g(r,a) = s \neq fail$}
            \State $queue\gets queue \cup \{s\}$
            \State $state\gets f(r)$
            \While{$g(state,a) = fail$}
              \State $state\gets f(state)$
            \EndWhile
            \State $f(s)\gets g(state,a)$              
          \EndFor
        \EndWhile
          
      \EndFunction

    \end{algorithmic}
  \end{algorithm}


  \begin{algorithm}

    %% OMIN SANOIN
    \caption{Ukkonen90 algorithm 1, preprocessing} \label{ukk-pre}
    \hspace*{\algorithmicindent} \textbf{Input:} Set $R=\{x_1,...,x_m\}$ of strings, and the goto function $g$ and the failure function $f$ for $R$.\\
    \hspace*{\algorithmicindent} \textbf{Output:} Depth $d(s)$, list $L(s)$ and link $b(s)$ for each state $s$ of the AC machine; Pointer $B$ to the first state in the $b$-link chain; state $F(i)$ representing string $x_i$ for each $x_i$ with the exception that if $x_i$ is a substring of another string in $R$ then $F(i) = 0$.\\
    \hspace*{\algorithmicindent} \textbf{Notation:} operator $\cdot$ denotes list catenation. An inverse of $F$ is represented by $E$: if $F(i) = s$ then $E(s) = i$; initially $E(s) = 0$ for every state s.\\
    
    \begin{algorithmic}[1]
      \Function{calculateAuxiliaryFunctions}{$g : \mathbb{N} \rightarrow \mathbb{N}$, $f : \mathbb{N} \rightarrow \mathbb{N}$}
        \For {$i = 1,...,m$}
          \hspace*{\algorithmicindent} let $x_i = a_1,...,a_k$
          \State $s\gets 0$
          \For {$j = 1,...,k$}
            \State $s\gets g(s,a_j)$
            \State $L(s)\gets L(s) \cdot \{j\}$
            \If {$j = k$}
              \State $F(i)\gets s$
              \State $E(s)\gets i$
              \If {$s$ is not a leaf of the AC machine}
                \State $F(i)\gets 0)$
              \EndIf
            \EndIf
          \EndFor
        \EndFor
        \State $queue\gets 0$
        \State $d(0)\gets 0$
        \State $B\gets 0$
        \While{$queue\neq empty$}
          \hspace*{\algorithmicindent} let $r$ be the next state in queue
          \State $queue\gets queue \backslash \{r\}$
          \For {each $s$ s.t. $g(r,a) = s$ for some $a$}
            \State $queue\gets queue\cdot s$
            \State $d(s)\gets d(r)+1$
            \State $b(s)\gets B$
            \State $F(E(f(s)))\gets 0$
          \EndFor
        \EndWhile
      \EndFunction
        
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}
    %% TODO: omin sanoin input, output.
    \caption{Ukkonen90 Algorithm 2 Construction of H} \label{ukk-h}
    \hspace*{\algorithmicindent} \textbf{Input:} Augmented AC machine for $R$ as constructed by ref\\ %ref?
    \hspace*{\algorithmicindent} \textbf{Output:} A Hamiltonian path $H$ in the overlap graph of reduced $R$. A common superstring for $R$ can then be constructed by forming $p(H)$.\\

    \begin{algorithmic}[1]
      \Function{createPath}{Outputs of the previous functions, Set of keywords $R = \{k_1,...,k_m\}$}
        \For {$j = 1,...,m$}
          \If {$F(j)\neq 0$}
            \State $P(f(F(j)))\gets P(f(F(j)))\cdot {j}$
            \State $FIRST(j)\gets j$
            \State $LAST(j)\gets j$
          \Else
            \State $forbidden(j)\gets true$
          \EndIf
        \EndFor  
        \State $s\gets b(B)$
        \While {$s\neq 0$}
          \If {$P(s)$ is not empty}
            \For {each $j$ in $L(s)$ s.t. $forbidden(j) = false$}
              \State $i\gets$ the first element of $P(s)$
              \If {$FIRST(i) = j)$}
                \If {$P(s)$ has only one element}
                  \hspace*{\algorithmicindent} \textbf{goto} \textit{next}
                \Else
                  \State $i\gets$ the second element of $P(s)$
                \EndIf
              \EndIf  
            \State $H\gets H\cdot \{(x_i,x_j)\}$
            \State $forbidden(j)\gets true$
            \State $FIRST(LAST(j))\gets FIRST(i)$
            \State $LAST(FIRST(i))\gets LAST(j)$
            \hspace*{\algorithmicindent} \textit{next:}
            \EndFor
          \State $P(f(s))\gets P(f(s))\cdot P(s)$
          \EndIf
          \State $s\gets b(s)$
        \EndWhile
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
  


  \section{correctness}


%%
\chapter{Relative Lempel-Ziv}

  Lempel-Ziv dictionary construction.

  subsections?

%%
\chapter{experiments}

  \section{Implementation}

  \section{Benchmark Data}
  HW + instances

  \section{Results}

  \section{Discussion}

%
\chapter{Conclusions}
  

  \begin{enumerate}
  \item \citep{aho75} describes the Aho-Corasic machine for the first time. It gives the pseudocode to creation and search.
  \item alanko dissertation, no bibtex yet. Discusses some things related to this topic.
  \item \citep{alanko17} describes approx scs algorithm for compact space.
  \item statistics.pdf desccribes the dataset pizzachili.
  \item \citep{ukkonen90} is the most important reference in this thesis. Describes the main scs algorithm.
  \item \citep{tarhio88} Describes the same algorithm as ukkonen 90 but not in linear time.
  \end{enumerate}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage                          %fixes the position of bibliography in bookmarks
\phantomsection
\addcontentsline{toc}{chapter}{\bibname}  % This lines adds the bibliography to the ToC
\printbibliography

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter

%
% TARVIINKO APPENDICES??
%
%

\begin{appendices}

%\input{instructions_english}
%% \input{instructions_finnish}

%% \appendix{Sample Appendix\label{appendix:model}}
%% usually starts on its own page, with the name and number of the appendix at the top. 
%% The appendices here are just models of the table of contents and the presentation. Each appendix
%% Each appendix is paginated separately.

%% In addition to complementing the main document, each appendix is also its own, independent entity.
%% This means that an appendix cannot be just an image or a piece of programming, but the appendix must explain its contents and meaning.

\end{appendices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
